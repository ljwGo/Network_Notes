[toc]

# 传输层基本服务

1. ## 传输层功能

   实现数据[^端到端]的逻辑通信服务

   [^端到端]:数据从服务端的某个应用进程，发送给客户主机后，交由客户机的哪个应用进程

   ![传输层功能](D:\Notes\计算机网络\传输层\2021-11-14_170306.png)

2. ## 端口

   端口号用来唯一标识计算机上的某个联网应用进程

   > 有了端口号做区别，操作系统就知道统一从网卡进入的数据，该交给哪个应用程序

   *端口号范围：*0 ~ 65535

   *系统端口号*：0 ~ 1023

   *登记端口号：*1024 ~ 49151

   *临时端口号*：49152 ~ 65535

   | 常用端口号 |       应用       |
   | :--------: | :--------------: |
   |   TCP 20   |   FTP 数据发送   |
   |   TCP 21   |   FTP 指令发送   |
   |   TCP 22   |       SSH        |
   |   UDP 53   |     DNS服务      |
   |   TCP 80   |     web服务      |
   |  TCP 110   | POP3邮局读取协议 |
   |  TCP 3306  |    Mysql端口     |

   **注意**：<u>这里的端口号占用指的是**服务端而非客户端**</u>

3. ## 传输层协议

   ![传输层协议](D:\Notes\计算机网络\传输层\2021-11-14_170504.png)

   TCP：

   >可靠传输，会保证数据被接收方正确接收。需要在真正发送数据前，双方建立连接，连接建立成功后再发送数据。
   >
   >缺点是效率较低

   UDP：

   > 非可靠传输，不保证数据一定被接收方接收。不需要建立连接，效率较高
   >
   > 缺点是不可靠

# 传输层的复用和分解

1. ## 什么是复用和分解

   *复用：*同一个传输层需要服务计算机上的多个应用进程；

   *分解：*传输层能够正确的将数据交给不同端口号的应用程序，而不是将数据的筛选工作交给应用进程

2. ## UDP的复用和分解

   UDP实现复用与分解依据 <u>< 目的IP + 目的端口号></u>

   ![UDP复用和分解](D:\Notes\计算机网络\传输层\2021-11-14_170954.png)

   >UDP连接只会为**一个端口**开设**一个独立的缓存池**。
   >
   >不同计算机上不用应用程序，只要是和该端口的应用通信，**所有提交的数据都会被放到该缓存池中**

   ![UDP复用与分解理解](D:\Notes\计算机网络\传输层\2021-11-14_172741.png)

   

3. ## TCP的复用和分解

   TCP实现复用与分解依据 <u><源IP + 源端口号 + 目的IP + 目的端口号></u>

   ![TCP复用和分解](D:\Notes\计算机网络\传输层\2021-11-14_171020.png)

   > TCP会为每个连接提供一个缓存池，一个端口可能有多个缓存池

   ![TCP复用与分解理解](D:\Notes\计算机网络\传输层\2021-11-14_173416.png)

# 可靠传输TCP

1. ## TCP实现可靠传输的保证

   * 差错检测：根据报文段头部的**效验和**进行

     [^效验和]:将报文头部和数据部分以16位为单位，按一定规律分组相加求和（有最高进位则结果再相加）

   * 确认：接收方接收到数据后需要发送确认，告知发送方接收状态

   * 重传：接收方没有发送确认或者数据有误时重传

   * 序号：判断接收数据的先后顺序，以及是否有缺失数据未接收

   * 计时器：规定多长时间没接收确认视为数据丢失

   

2. ## 停-等协议和滑动窗口协议

   停等协议和滑动窗口协议是为了保证**数据能够被接收**

   *停等协议：*

   ![停等协议](D:\Notes\计算机网络\传输层\2021-11-14_171158.png)

   注：停等协议不需要使用<u>序号</u>

   ![停等协议问题](D:\Notes\计算机网络\传输层\2021-11-14_171229.png)

   

   *滑动窗口协议：*

   ![滑动窗口协议](D:\Notes\计算机网络\传输层\2021-11-14_171255.png)

   > 滑动窗口协议，**一次**发送发送**多个分组**。
   >
   > 当前发送窗口中**最小序号**的分组收到确认后，窗口往后移动
   >
   > 需要发送方和接收方能够对分组进行**缓存**
   >
   > 发送方进行缓存，为了当某个分组没有接收到确认时，**重传**，收到确认后就可以清除掉该分组缓存
   >
   > 接收方将**乱序的分组**进行缓存，如果直接交给应用，会造成**数据错乱**；直接丢弃则会影响**传输效率**

   ## 典型的滑动窗口协议

   ![典型的滑动窗口协议](D:\Notes\计算机网络\传输层\2021-11-14_171359.png)

   

3. ## TCP报文段

   ![TCP报文段](D:\Notes\计算机网络\传输层\2021-11-14_171503.png)

   * 源端口和目的端口

   * 序号seq：（**发送方给接收方**）表示当前是发送方发送的第几个分组。对方判断是否有分组未接收，是否有分组重复等

   * 确认号ack：（**接收方给发送方**）表示发送方的第几分组接收方已经接收，希望接收的下一分组的序号

   * 数据偏移（首部长度）：表示**数据部分距离TCP报文段头部的距离**，该距离是4字节的倍数。一般等于首部长度；也用于区分相同序号的报文段再被分割成不同段的前后顺序

   * 保留：6位，供以后使用

   * 标志位：URG，表示紧急指针位是否可用；**ACK，表示确认号是否可用**；PSH，该信息被快速发送；PST，重置；**SYN，同步请求**；FIN，断开连接的请求

   * 窗口：窗口大小

   * 效验和：用于差错检测

   * 紧急指针

   * 可选字段与填充

     

4. ## 三次握手和四次挥手

   ![三次握手](D:\Notes\计算机网络\传输层\2021-11-14_171606.png)

   > 1、客户端发送**SYN同步请求**，告诉服务端，我发送的**分组序号初始值为x**
   >
   > 2、服务端接收到同步请求，发送**ACK确认请求**，**ack=x+1**表示**x和x之前的分组我都接收到**了，**希望接收序号为x+1**的分组。
   >
   > 同时带有同步请求，告知客户端我发送的分组，序号从y开始
   >
   > 3、客户端发送ACK确认请求，ack=y+1表示y和y之前的分组我都接收到了，希望接下来接收序号为y+1的分组
   >
   > 同时seq=x+1表示当前分组序号为x+1

   ![四次挥手](D:\Notes\计算机网络\传输层\2021-11-14_171624.png)

   **自己的思考**

   > 滑动窗口协议不会出现这样的冲突吗？
   >
   > **ack=x+1和ack=(x-1)+2**
   >
   > 比如：4没有收到，5收到，6没有收到。此时服务端发送接收到分组4，发送ack=6（4+2）；客户端理解成ack=6（5+1）
   >
   > 好像也没问题，哈哈:smile:
   >
   > 那么，对于**乱序的分组**发送确认没问题吗？
   >
   > 比如：4没收到，5没收到，6收到了
   >
   > 是直接发送ack=7?
   >
   > 我的理解是，**对于乱序的分组不会立刻发送确认**，不知道对不对

5. ## 网络拥塞控制协议AIMD

   Additive Increase Mutilative Decrease 加性增加，乘性减小

   > 不断试探，根据**收到确认的时间**判断网络是否拥塞。
   >
   > 如果不拥塞，则**慢慢增大**发送窗口的大小
   >
   > 如果拥塞，则**迅速减小**发送窗口的大小

   ![拥塞控制](D:\Notes\计算机网络\传输层\2021-11-14_171758.png)

6. ## 流量控制

   ![流量控制](D:\Notes\计算机网络\传输层\2021-11-14_171724.png)

# UDP

1. ## UDP报文

   ![UDP报文](D:\Notes\计算机网络\传输层\2021-11-14_171432.png)